<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="libs/p5.js"></script>

</head>

<body>
    <script>
        let cam;
        let img;

        let planet
        let planet2
        let cents18Font;
        let slider1, slider2, slider3, slider4, slider5;
        function preload() {
            img = loadImage('assets/texture.jpeg');
            cents18Font = loadFont('assets/18cents.ttf');
        }

        function setup() {
            textSize(32);
            textFont('Georgia');

            createCanvas(400, 400, WEBGL);
            cam = createCamera();
            //m = createModel();
            planet = new Planet(20)
           // planet2 = new Planet()
            //planet.radius=10
            //noiseSeed(99);

           // planet.createModel()
              // planet2.createModel()
            // res=41 radius=1.75  strech=0.51  roughness=4.39  cente=2.86, 1.84, 2.48  

            paragraph = createP('starting text');
            // radius
            slider1 = createSlider(0, 10, 1.75, 0.01);
            slider1.position(20, 10);
            slider1.style('width', '80px');
            slider1.input(updateSliders);
            //roughness
            slider2 = createSlider(0, 20, 4.39, 0.01);
            slider2.position(20, 30);
            slider2.style('width', '80px');
            slider2.input(updateSliders);
            // strength
            slider3 = createSlider(0, 3, 1, 0.01);
            slider3.position(20, 50);
            slider3.style('width', '80px');
            slider3.input(updateSliders);
            // center
            slider4 = createSlider(0, 3, 2.86, 0.01);
            slider4.position(20, 70);
            slider4.style('width', '80px');
            slider4.input(updateSliders);

             // minValue2
            slider5 = createSlider(0, 2, 0.8, 0.001);
            slider5.position(20, 90);
            slider5.style('width', '80px');
            slider5.input(updateSliders);

             // base rouge
            slider6 = createSlider(0, 2, 0.8, 0.001);
            slider6.position(20, 110);
            slider6.style('width', '80px');
            slider6.input(updateSliders);

            textFont(cents18Font);
            //noStroke();
            updateSliders()
        }

        function updateSliders() {
            planet = new Planet(20)

            planet.radius = slider1.value()
            planet.noiseFilter.roughness = slider2.value()
            planet.noiseFilter.strength = slider3.value()
            planet.noiseFilter.center = new p5.Vector(slider4.value(), 1.84, 2.48)
            planet.noiseFilter.minValue2 = slider5.value()
            planet.noiseFilter.baseRoughness = slider6.value()
            planet.createModel()
            console.log('camia')

        }





        function draw() {
            background(100);
            text('ra', -width / 2 + 5, -height / 2 + 10)
            text('ro', -width / 2 + 5, -height / 2 + 30)
            text('st', -width / 2 + 5, -height / 2 + 50)
            text('ce', -width / 2 + 5, -height / 2 + 70)
            text('mv', -width / 2 + 5, -height / 2 + 90)
            text('br', -width / 2 + 5, -height / 2 + 110)


            // text('racasd',100,100)
            // fill(0, 102, 153);

            orbitControl();
           
           // fill('black');


            //       specularMaterial(250);
            shininess(50);
            ambientLight(50);

            //normalMaterial()
            // Shine a light in the direction the camera is pointing
            directionalLight(
                240, 240, 240,
                cam.centerX - cam.eyeX,
                cam.centerY - cam.eyeY,
                cam.centerZ - cam.eyeZ
            );

           // stroke('white');
           noStroke();
            //rotateY(0.5);
            torus(1,1);

            push()
            scale(70)
            // translate(1, 1)

          //  texture(img);
            //            normalMaterial();
            //

            //ambientMaterial(70, 130, 230);

          //  if (planet) planet.model();
          if (planet) planet.model()

            pop()

              push()
              //scale(70)
             // if (planet2) planet2.model();
              pop()
              


        }




        class NoiseFilter {
            constructor() {
                this.minValue2 = 0.5;
                this.strength = 1;
                this.numLayers=3
                this.baseRoughness=1
                this.roughness = 2;
                this.persistence=0.5
                this.center = p5.Vector(0,0,0);
            }

            evaluateOld(point) {
                const v = p5.Vector.mult(point, this.roughness).add(this.center);
                let noiseValue = (noise(v.x, v.y, v.z) + 1) * 0.5;
               // console.log(noiseValue,n, this.minValue2,max(0, n),this.strength, this.roughness)
                noiseValue = Math.max(0, noiseValue-this.minValue2);
               // console.log(noiseValue)
                return noiseValue * this.strength
            }
            evaluate(point) {
                let noiseValue= 0
                let frecuency = this.baseRoughness
                let amplitude = 1
                for(let i=0;i<this.numLayers;i++){
                    const vec = p5.Vector.mult(point, frecuency).add(this.center);
                    const v = noise(vec.x, vec.y, vec.z)
                    noiseValue += (v + 1) * 0.5 * amplitude
                    frecuency *= this.roughness
                    amplitude *= this.persistence
                }
                //console.log(this.minValue2)
                noiseValue = Math.max(0, noiseValue-this.minValue2)
                
                return noiseValue * this.strength
            }
        }


        class Planet {

            constructor(resolution = 41) {
                this.resolution = resolution;
                this.models = []
                this.radius = 2
                this.noiseFilter = new NoiseFilter()

            }

            calculatePointOnPlanet(pointOnUnitSphere) {
                let elevation = this.noiseFilter.evaluate(pointOnUnitSphere)
                return pointOnUnitSphere.mult(this.radius).mult(1 + elevation)
            }


            createSection(localUp) {

                function createMesh(localUp, the_planet) {
                    //the_planet.resolution=30

                    const axisA = new p5.Vector(localUp.y, localUp.z, localUp.x)
                    const axisB = p5.Vector.cross(localUp, axisA)

                    let i = 0
                    for (let y = 0; y < the_planet.resolution; y++) {
                        for (let x = 0; x < the_planet.resolution; x++) {
                            const percent = new p5.Vector(x, y).div(the_planet.resolution - 1);
                            const ta = p5.Vector.mult(axisA, (percent.x - 0.5) * 2)
                            const tb = p5.Vector.mult(axisB, (percent.y - 0.5) * 2)
                            const pointOnUnitCube = p5.Vector.add(p5.Vector.add(localUp, ta), tb).normalize()

                            this.vertices.push(the_planet.calculatePointOnPlanet(pointOnUnitCube));

                            if (x != the_planet.resolution - 1 && y != the_planet.resolution - 1) {
                                this.faces.push([i, i + the_planet.resolution + 1, i + the_planet.resolution]);
                                this.faces.push([i, i + 1, i + the_planet.resolution + 1]);
                            }
                            i++


                        }
                    }

                    //this.computeFaces();
                    this.computeNormals();
                    this.gid = `sect|${the_planet.radius}|${the_planet.resolution}|${localUp.x}|${localUp.y}|${localUp.z}|${the_planet.noiseFilter.roughness}|${the_planet.noiseFilter.center}|${the_planet.noiseFilter.strength}|${the_planet.noiseFilter.minValue2}|${the_planet.noiseFilter.numLayers}|${the_planet.noiseFilter.baseRoughness}|${the_planet.noiseFilter.persistence}`;
                }

                const the_planet = this
                return new p5.Geometry(
                    // detailX and detailY are not used in this example
                    1, 1,
                    // The callback must be an anonymous function, not an arrow function in
                    // order for "this" to be bound correctly.
                    function () { createMesh.call(this, localUp, the_planet) }
                );

            }


            createModel() {
                const directions = [new p5.Vector(1, 0, 0), new p5.Vector(-1, 0, 0), new p5.Vector(0, 1, 0), new p5.Vector(0, -1, 0), new p5.Vector(0, 0, 1), new p5.Vector(0, 0, -1)]
                this.models = []
                for (let i = 0; i < 6; i++) {
                    let localUp = directions[i]
                    const m = this.createSection(localUp);
                    this.models.push(m)
                }
            }

            model() {
                for (let i = 0; i < this.models.length; i++) {
                    model(this.models[i])
                }
            }

        }

    </script>
</body>

</html>